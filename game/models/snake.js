class Snake extends GameObject
{
    constructor(startX, startY, startingLength, height, width, segmentType = constants.SNAKE_DEFAULT_SEGMENT_TYPE)
    {
        super(startX, startY, height, width);

        this._direction = directions.none;
        this._body = new SnakeBodyDequeue(new LinkedSnakeSegment(constants.SNAKE_STARTING_X, constants.SNAKE_STARTING_Y, height, width, segmentType), segmentType);

        for (let current = 1; current < startingLength; ++current)
        {
            this.extendWithAutoGeneratedSegment();
        }

        this._allSegmentXCoordinates = new Set(this.body.mapToArray((segment) => segment.x));
        this._allSegmentYCoordinates = new Set(this.body.mapToArray((segment) => segment.y));
        // debugger;
    }

    get direction()
    {
        return this._direction;
    }

    set direction(value)
    {
        this._direction = value;
    }

    get head()
    {
        return this.body.head;
    }

    get body()
    {
        return this._body;
    }

    set body(value)
    {
        this._body = value;
    }

    get x()
    {
        return this.body.head.x;
    }

    set x(value)
    {
        this.head.body.x = value;
    }

    get y()
    {
        return this.body.head.y;
    }

    set y(value)
    {
        this.head.body.y = value;
    }

    get segments()
    {
        return this._body;
    }

    get speed()
    {
        return this._speed;
    }

    set speed(value)
    {
        this._speed = +value;
    }

    get allSegmentXCoordinates()
    {
        return this._allSegmentXCoordinates;
    }

    set allSegmentXCoordinates(value)
    {
        this._allSegmentXCoordinates = value;
    }

    get allSegmentYCoordinates()
    {
        return this._allSegmentYCoordinates;
    }

    set allSegmentYCoordinates(value)
    {
        this._allSegmentYCoordinates = value;
    }

    moveToCoordinates(x, y)
    {
        this.body.head.x = x;
        this.body.head.y = y;
    }

    changeDirection(newDirection)
    {
        this.direction = newDirection;
    }

    move(speed)
    {
        const nextCoordinates = this._getDeltaForDirection(speed);
        const lastMovedSegment = this.body.popRightmostElement();

        if (constants.GAME_IS_IN_DEBUG_MODE)
        {
            console.log(`${this.direction} -> X:${nextCoordinates.x}, Y:${nextCoordinates.y}, Speed:${speed}`);
        }

        // console.log(lastMovedSegment);

        this.allSegmentXCoordinates.delete(lastMovedSegment.x);
        this.allSegmentYCoordinates.delete(lastMovedSegment.y);

        this.allSegmentXCoordinates.add(this.body.head.x);
        this.allSegmentYCoordinates.add(this.body.head.y);

        lastMovedSegment.y = (this.body.head.y + nextCoordinates.y);
        lastMovedSegment.x = (this.body.head.x + nextCoordinates.x);

        // if (speed !== 0) debugger;

        this.body.addToHead(lastMovedSegment);
    }

    // TODO: Method needs implementation
    hasBittenItsTail()
    {
        // Will never work without better segment spacing
        const allSegmentXCoordinates = this.allSegmentXCoordinates;
        const allSegmentYCoordinates = this.allSegmentYCoordinates;

        const tailHasBeenCannibalized =
            allSegmentXCoordinates.has(this.body.head.x) &&
            allSegmentYCoordinates.has(this.body.head.y);

        return false;
    }

    extendWithAutoGeneratedSegment()
    {
        const newSegment = new LinkedSnakeSegment(this.body.head.x, this.body.head.y, this.height, this.width, this.body.type);
        this._addSegment(newSegment);
    }

    caughtFeed(feed)
    {
        const feedHasBeenCaught = helpers.objectsAreColliding(feed, this.body.head);

        if (feedHasBeenCaught)
        {
            this.extendWithAutoGeneratedSegment();
        }

        return feedHasBeenCaught;
    }

    _addSegment(segment)
    {
        this.body.addToTail(segment);
        console.log(`Feed caught, snake extended to ${this.body.length}`);
    }

    _getDeltaForDirection(speed)
    {
        if (constants.GAME_IS_IN_DEBUG_MODE)
        {
            console.log(`Speed:${speed}`);
        }

        const directionDeltas = {};
        directionDeltas[directions.none] = { x: 0, y: 0 };
        directionDeltas[directions.up] = { x: 0, y: -speed };
        directionDeltas[directions.down] = { x: 0, y: speed };
        directionDeltas[directions.left] = { x: -speed, y: 0 };
        directionDeltas[directions.right] = { x: speed, y: 0 };

        return directionDeltas[this.direction];
    }
}